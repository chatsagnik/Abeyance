AbeyanceSagnik ChatterjeeMay 20171  Problem Statement: Find the Minimum Average Latency of a Non-Linear PipelineA  Pipeline  is  a  modified  queue  designed  to  implement  instruction-level  par-allelism  in  a  CPU.  Using  the  concept  of  Pipelining  we  can  overlap  multipleinstructions in execution.The computer pipeline is divided in a number of stages.  Each stage completesa part of an instruction in parallel.  The stages are connected to each other toform a pipe - instructions enter at one end,  progress through the stages,  andexit at the other end.Before we proceed, a few important things to note about pipelines are:•Pipelining does not decrease latency or the time for individual instructionexecution.•Pipelining  increases  instruction  throughput.   The  throughput  of  the  in-struction  pipeline  is  determined  by  how  often  an  instruction  exits  thepipeline.•Pipelining implements a form of parallelism called instruction-level paral-lelism within a single processor.1.1  Non-Linear PipeliningUnlike traditional pipelines (or linear pipelines),dynamicor non-linear pipelinesallow for feedback and feed-forward connections between the various stages ofa pipeline.A couple of key differences between linear pipelines and non-linear pipelines are:•The Output of a Dynamic Pipeline is not necessarily produced from thelast stage.•Non-Linear Pipelines can be reconfigured to perform different actions atdifferent times.1
 2  DesignThe main crux of the problem is:  Given a reservation table of a pipeline, findthe minimum average latency for the pipeline.2.1  InputA 2D array consisting of 0’s and 1’s.  The rows represent the pipeline stages,and the columns represent the clock cycles.  1’s in the 2D array represent theclock cycle at which an instruction was initiated in a particular pipeline stage.2.2  OutputOur program produces the following output on being provided with a reservationtable:•A single floating point value denoting the minimum average latency of thegiven pipeline.•A list of all possible average latencies in the given pipeline.•A description of all the states in the state diagram. This includes a detaileddescription of all the vertices and the edges present in the state diagram.•A Text File containing all the elementary cycles possible in the state dia-gram.  AnElementary Cycleis one in which no vertex is repeated twiceexcept for the start node.2.3  Procedure:  The whole process can be divided into 8 atomic stages which must be con-ducted sequentially for us to derive the aforementioned outputs from the reser-vation table.  These stages are listed below:1.  Find non-repeating Forbidden Latencies from reservation table.2.  Sort this list in ascending order and form the initial collision vector.3.  Start constructing the state diagram from the initial collision vector.4.  Convert the state diagram into a directed graph.5.  Find all elementary cycles in the aforementioned directed graph.6.  Find the average latency for each such mentioned elementary cycle.7.  Select  all  elementary  cycles  with  average  latency  which  is  less  than  thenumber of forbidden latencies.8.  Select the smallest such latency.2
 3  Main Design IssuesThere were four main design issues in the whole program, which are listed asfollows:1.  Designing the structure which would be used for representing the differentstates of the state diagram.2.  Actually populating the state diagram.3.  Converting the state diagram into a directed graph.4.  Finding all Elementary Circuits of the directed graph.3.1  Designing the StatesEach state is based on it’s unique collision vector.  Also each state has an arrayof next states, and edge weights in a One-One correspondence with every ele-ment of the next states.After some deliberation we came up with the following structures to accommo-date the aforementioned specifications:struct collisionVector{int arr[COL];int length;};struct state{int value;struct collisionVector* cv;struct state* next[SIZE];int latency[SIZE];};3.2  Creating a Directed Graph representing the State Di-agramThe functionpopulateDiagram() basically does a depth first population of thestate diagram.  It takes each node as it is created, and computes every possiblechild node (and the edges to these child nodes).  Later the function is recursivelycalled for every child node if they have not been populated earlier.While  each  node  is  being  thus  populated,  we  are  simulataneously  construct-ing  an  Adjacency  List  representation  of  the  Directed  Graph  which  the  StateDiagram ultimately represents.functionpopulateDiagram()Input:3
 •struct state∗f irstStateThis is the very first state created from the initial collision vector.  Thisstate serves as the seed for the population process of the State Diagram.•struct collisionV ector∗initialV ectorThis is the initial collision vector which was created from the input reser-vation table.Output:  NoneGlobal Variables:•struct state∗adjacencyList[]This is an Adjacency List used to store the directed graph notation of thestate diagram.•struct state∗traversedArray[]This is a hashtable used to implement the Depth First population of thestates in the state diagram.Algorithm:Begin:1.  Set traversedArray value for firstState as True.2.  Traverse over the initial collision vector.a.  For every right shifted 0, we have two things -a new state configuration, and a latency associated with the new state.b.  Update this new state and the associated latencyas a child node and edge of the given firstState.c.  Update this as a node in the adjacency list entry for firstState.3.  Mark firstState as traversed.4.  For every child of firstState recursively call populateDiagram()if it is not traversed.End3.3  Finding all Elementary Cycles of a Directed GraphThis problem is a well known NP-Hard problem (possibly even PSPACE). Inour ignorance, at first we tried doing a simple DFS search (modified to fit ourneeds)  on  the  adjacency  list.   However  the  search  yielded  results  which  wereduplicate, and ignored some crucial cycles in the graph.  This lead us to realizethat there was more to this particular problem than met the eye, and we startedresearching on the topic.4
 We came up with quite a few papers published from 1970 (by Tiernan) to 1975(by Johnson) that gave approximate algorithms to solve the problem.  The bestalgorithm in this case was clearly Johnson’s algorithm by his own admission.  InDonald B. Johnson’s 1975 paper on the same topic he says,””There are exactlyn−1∑i=1(nn−i+ 1)(n−i)!elementary  circuits  in  a  complete  directed  graph  withnvertices.Thus  the  number  of  elementary  circuits  in  a  directed  graph  cangrow faster with n than the exponential 2n.  So it is clear that ouralgorithm,  which  has  a  time  bound  ofO((n+e)(c+ 1))  on  anygraph withnvertices,eedges andcelementary circuits, is feasiblefor a substantially larger class of problems than the best algorithmspreviously known which realize a time bound ofO(n.e(c+ 1)).””This shows that even after reducing the Running Time complexity by an orderofO(e.(c+ 1)), we were still left with an exponential time complexity since thenumber of elementary circuits in the graph could itself be exponential in nature.Also just because Johnson’s algorithm was the best in terms of running timecomplexity, didn’t mean it was the most adaptable to our situation.  Note thatJohnson’s algorithm itself is not explained in detail here, as we ended up usingour own modified version.  We had to code the programentirely in ANSI C,and Johnson’s algorithm provided the following challenges:•We needed to implement an algorithm to find and return Strongly Con-nected  Components  to  the  main  algorithm.   This  meant  implementingeither  Tarjan’s  algorithm  or  Kosaraju’s  algorithm  and  somehow  return-ing the set of Strongly Connected Components to the main algorithm toprocess.•Johnson’s algorithm itself needs complicated datastructures like a blocketset and a blocked map, which are quite tricky to implement in C.We made the following discoveries which led to our own modified algorithm:•The Blocking Mechanism in Johnson’s algorithm could be ignored with apenalty induced in the running time, but on the other hand simplifying theprocess manifold by removing dependency on any external Data Structureexcept for a stack.•The initial state diagram is always a strongly connected component.  Andeven if resultant state diagrams (after removing vertices) aren’t stronglyconnected components, we just incur an extra penalty ofO(n2) at mostfor searching through the adjacency list looking for cycles that don’t exist.A concise algorithm for our implementation is given as follows:5
 Begin
